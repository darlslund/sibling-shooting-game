<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NEXUS ARENA - Multiplayer Combat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }
    #root {
      width: 100vw;
      height: 100vh;
    }
  </style>
  <!-- Load React and ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Load Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Load Babel Standalone for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">

const SpaceCombatGame = () => {
  // Game states
  const [gameState, setGameState] = useState('lobby'); // 'lobby', 'menu', 'playing', 'paused'
  const [playerName, setPlayerName] = useState('');
  const [selectedTeam, setSelectedTeam] = useState(null);

  // Multiplayer state
  const [multiplayerState, setMultiplayerState] = useState({
    isConnected: false,
    roomCode: '',
    joinCode: '',
    playerId: null,
    players: new Map(), // Other players in the room
    error: null
  });
  const wsRef = useRef(null);

  // Player state
  const [player, setPlayer] = useState({
    position: { x: 0, y: 0, z: 0 },
    rotation: 0,
    health: 100,
    maxHealth: 100,
    xp: 0,
    level: 1,
    team: null,
    isDead: false,
    deathTime: 0,
    upgrades: {
      damage: 1,
      fireRate: 1,
      extraCannons: [],
      directions: ['front']
    }
  });

  // Admin state
  const [adminConsole, setAdminConsole] = useState({
    isOpen: false,
    noHealthDecay: false,
    command: ''
  });

  // Bot configuration state
  const [botConfig, setBotConfig] = useState({
    black: 0,
    purple: 0,
    yellow: 0
  });

  // Upgrade selection state
  const [showUpgradeScreen, setShowUpgradeScreen] = useState(false);
  const [availableUpgradeChoices, setAvailableUpgradeChoices] = useState([]);

  // Mouse position
  const mousePosition = useRef({ x: 0, y: 0, worldX: 0, worldZ: 0 });

  const [enemies, setEnemies] = useState([]);
  const [rocks, setRocks] = useState([]);
  const [projectiles, setProjectiles] = useState([]);
  const [particles, setParticles] = useState([]);
  const [bushes, setBushes] = useState([]);
  const [trees, setTrees] = useState([]);
  
  // Refs
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const playerMeshRef = useRef(null);
  const keysPressed = useRef({});
  const lastShotTime = useRef(0);
  const lastUpdateTime = useRef(0);
  const animationFrameId = useRef(null);
  
  // Team configurations
  const teams = {
    black: { name: 'Black Team', color: 0x1a1a1a, glowColor: '#1a1a1a' },
    purple: { name: 'Purple Team', color: 0x9933ff, glowColor: '#9933ff' },
    yellow: { name: 'Yellow Team', color: 0xffff00, glowColor: '#ffff00' }
  };

  // Team spawn areas
  const spawnAreas = {
    black: { x: -30, z: -30, radius: 10 },
    purple: { x: 30, z: 30, radius: 10 },
    yellow: { x: 30, z: -30, radius: 10 }
  };

  // Helper function to get spawn position for a team
  const getSpawnPosition = (team) => {
    const spawn = spawnAreas[team];
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * spawn.radius;
    return {
      x: spawn.x + Math.cos(angle) * distance,
      z: spawn.z + Math.sin(angle) * distance
    };
  };
  
  // WebSocket connection management
  useEffect(() => {
    const connectWebSocket = () => {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}`;
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        console.log('Connected to multiplayer server');
        setMultiplayerState(prev => ({ ...prev, isConnected: true, error: null }));
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleServerMessage(data);
        } catch (error) {
          console.error('Error parsing server message:', error);
        }
      };

      ws.onclose = () => {
        console.log('Disconnected from server');
        setMultiplayerState(prev => ({ ...prev, isConnected: false }));
        // Attempt to reconnect after 3 seconds
        setTimeout(connectWebSocket, 3000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        setMultiplayerState(prev => ({ ...prev, error: 'Connection error' }));
      };

      wsRef.current = ws;
    };

    connectWebSocket();

    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  const handleServerMessage = (data) => {
    const { type } = data;

    switch (type) {
      case 'ROOM_CREATED':
        setMultiplayerState(prev => ({
          ...prev,
          roomCode: data.roomCode,
          playerId: data.playerId
        }));
        setGameState('menu');
        break;

      case 'ROOM_JOINED':
        setMultiplayerState(prev => ({
          ...prev,
          roomCode: data.roomCode,
          playerId: data.playerId
        }));
        setGameState('menu');
        break;

      case 'EXISTING_PLAYERS':
        const playersMap = new Map();
        data.players.forEach(p => {
          playersMap.set(p.id, p);
        });
        setMultiplayerState(prev => ({ ...prev, players: playersMap }));
        break;

      case 'PLAYER_JOINED':
        setMultiplayerState(prev => {
          const newPlayers = new Map(prev.players);
          newPlayers.set(data.player.id, data.player);
          return { ...prev, players: newPlayers };
        });
        console.log(`Player joined: ${data.player.name}`);
        break;

      case 'PLAYER_LEFT':
        setMultiplayerState(prev => {
          const newPlayers = new Map(prev.players);
          newPlayers.delete(data.playerId);
          return { ...prev, players: newPlayers };
        });
        console.log(`Player left: ${data.playerId}`);
        break;

      case 'PLAYER_UPDATE':
        setMultiplayerState(prev => {
          const newPlayers = new Map(prev.players);
          const player = newPlayers.get(data.playerId);
          if (player) {
            newPlayers.set(data.playerId, {
              ...player,
              position: data.position,
              rotation: data.rotation,
              health: data.health,
              level: data.level,
              xp: data.xp,
              upgrades: data.upgrades
            });
          }
          return { ...prev, players: newPlayers };
        });
        break;

      case 'PLAYER_SHOOT':
        // Create projectile from other player
        const shootPlayer = multiplayerState.players.get(data.playerId);
        if (shootPlayer && data.playerId !== multiplayerState.playerId) {
          const proj = {
            id: data.projectileId,
            position: { ...data.position },
            direction: data.direction,
            speed: 40,
            lifetime: 3,
            damage: 10,
            color: teams[shootPlayer.team]?.color || 0xff0000,
            isPlayerProjectile: false,
            ownerId: data.playerId
          };
          setProjectiles(prev => [...prev, proj]);
        }
        break;

      case 'PLAYER_DAMAGE':
        // Handle damage to other players
        console.log(`Player ${data.playerId} took ${data.damage} damage`);
        break;

      case 'PLAYER_DEATH':
        console.log(`Player ${data.playerId} died`);
        break;

      case 'PLAYER_LEVEL_UP':
        console.log(`Player ${data.playerId} leveled up to ${data.level}`);
        break;

      case 'ERROR':
        setMultiplayerState(prev => ({ ...prev, error: data.message }));
        console.error('Server error:', data.message);
        break;

      default:
        console.log('Unknown server message type:', type);
    }
  };

  const sendToServer = (message) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    }
  };

  const createRoom = () => {
    sendToServer({
      type: 'CREATE_ROOM',
      playerName: playerName,
      team: selectedTeam
    });
  };

  const joinRoom = (code) => {
    sendToServer({
      type: 'JOIN_ROOM',
      roomCode: code.toUpperCase(),
      playerName: playerName,
      team: selectedTeam
    });
  };

  const leaveRoom = () => {
    sendToServer({ type: 'LEAVE_ROOM' });
    setMultiplayerState(prev => ({
      ...prev,
      roomCode: '',
      playerId: null,
      players: new Map()
    }));
    setGameState('lobby');
  };

  // XP levels and requirements
  const getLevelRequirement = (level) => level * 100 + Math.pow(level, 2) * 50;
  
  const getAvailableUpgrades = (level) => {
    const upgrades = [];
    if (level >= 2) upgrades.push({ type: 'fireRate', name: 'Fire Rate +', description: 'Shoot faster' });
    if (level >= 3) upgrades.push({ type: 'damage', name: 'Damage +', description: 'More damage per shot' });
    if (level >= 4) upgrades.push({ type: 'extraCannons', value: 'side', name: 'Side Cannons', description: 'Shoot from sides' });
    if (level >= 5) upgrades.push({ type: 'extraCannons', value: 'back', name: 'Back Cannon', description: 'Shoot backwards' });
    if (level >= 6) upgrades.push({ type: 'extraCannons', value: 'diagonal', name: 'Diagonal Cannons', description: 'Shoot diagonally' });
    if (level >= 7) upgrades.push({ type: 'health', name: 'Max Health +', description: 'Increase max health' });
    return upgrades;
  };
  
  // Initialize Three.js scene
  useEffect(() => {
    if (gameState !== 'playing' || !mountRef.current) return;
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue
    scene.fog = new THREE.Fog(0x87CEEB, 15, 35); // Tighter fog so you can't see outside map
    sceneRef.current = scene;
    
    // Camera setup (bird's eye view) - zoomed in closer
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 25, 15);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(20, 40, 20);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    scene.add(directionalLight);
    
    // Create grass floor with texture
    const floorGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);

    // Create procedural grass texture
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');

    // Base grass color
    ctx.fillStyle = '#2d5016';
    ctx.fillRect(0, 0, 512, 512);

    // Add grass texture variation
    for (let i = 0; i < 10000; i++) {
      const x = Math.random() * 512;
      const y = Math.random() * 512;
      const shade = Math.random() * 40 - 20;
      const green = 80 + shade;
      const red = 45 + shade / 2;
      ctx.fillStyle = `rgb(${red}, ${green}, 16)`;
      ctx.fillRect(x, y, Math.random() * 3 + 1, Math.random() * 3 + 1);
    }

    const grassTexture = new THREE.CanvasTexture(canvas);
    grassTexture.wrapS = THREE.RepeatWrapping;
    grassTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.repeat.set(8, 8);

    const floorMaterial = new THREE.MeshStandardMaterial({
      map: grassTexture,
      roughness: 0.9,
      metalness: 0.0
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);
    
    // Arena walls
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: 0x0066cc,
      emissive: 0x003366,
      emissiveIntensity: 0.5,
      transparent: true,
      opacity: 0.3
    });
    
    const walls = [
      { pos: [0, 5, 50], rot: [0, 0, 0], size: [100, 10, 1] },
      { pos: [0, 5, -50], rot: [0, 0, 0], size: [100, 10, 1] },
      { pos: [50, 5, 0], rot: [0, Math.PI / 2, 0], size: [100, 10, 1] },
      { pos: [-50, 5, 0], rot: [0, Math.PI / 2, 0], size: [100, 10, 1] }
    ];
    
    walls.forEach(wall => {
      const geometry = new THREE.BoxGeometry(...wall.size);
      const mesh = new THREE.Mesh(geometry, wallMaterial);
      mesh.position.set(...wall.pos);
      mesh.rotation.set(...wall.rot);
      scene.add(mesh);
    });
    
    // Create human player character (bigger size)
    const createHumanCharacter = (color) => {
      const group = new THREE.Group();

      // Body - 1.5x bigger
      const bodyGeometry = new THREE.BoxGeometry(0.9, 1.5, 0.6);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.7,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.75;
      body.castShadow = true;
      group.add(body);

      // Head - 1.5x bigger
      const headGeometry = new THREE.SphereGeometry(0.45, 16, 16);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xffdbac,
        roughness: 0.8
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.95;
      head.castShadow = true;
      group.add(head);

      // Arms - 1.5x bigger
      const armGeometry = new THREE.BoxGeometry(0.3, 1.05, 0.3);
      const armMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.7
      });

      const leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.75, 0.9, 0);
      leftArm.castShadow = true;
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.75, 0.9, 0);
      rightArm.castShadow = true;
      group.add(rightArm);

      // Legs - 1.5x bigger
      const legGeometry = new THREE.BoxGeometry(0.375, 1.05, 0.375);
      const legMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.8
      });

      const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.3, -0.525, 0);
      leftLeg.castShadow = true;
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.3, -0.525, 0);
      rightLeg.castShadow = true;
      group.add(rightLeg);

      // Weapon indicator (points forward) - 1.5x bigger, positioned at right side
      const weaponGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.75);
      const weaponMaterial = new THREE.MeshStandardMaterial({
        color: 0x444444,
        metalness: 0.8
      });
      const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
      weapon.position.set(0.5, 1.2, 0.6); // Moved to right side
      group.add(weapon);

      return group;
    };

    const playerCharacter = createHumanCharacter(teams[selectedTeam].color);
    playerCharacter.position.set(player.position.x, 0, player.position.z);
    scene.add(playerCharacter);
    playerMeshRef.current = playerCharacter;
    
    // Generate initial leaf piles (formerly rocks)
    const initialRocks = [];
    for (let i = 0; i < 20; i++) {
      const size = Math.random() < 0.5 ? 'small' : 'large'; // Small or large piles
      const health = size === 'small' ? 20 : 40;
      initialRocks.push({
        id: Math.random(),
        position: {
          x: (Math.random() - 0.5) * 80,
          y: 0,
          z: (Math.random() - 0.5) * 80
        },
        health: health,
        maxHealth: health,
        rotation: Math.random() * Math.PI * 2,
        size: size,
        isDestroyed: false,
        destroyedTime: 0,
        respawnTime: size === 'small' ? 9000 : 13000 // 9s for small, 13s for large
      });
    }
    setRocks(initialRocks);
    
    // Generate enemy players based on bot configuration
    const initialEnemies = [];
    Object.keys(teams).forEach(teamKey => {
      const botCount = botConfig[teamKey] || 0;
      for (let i = 0; i < botCount; i++) {
        const spawnPos = getSpawnPosition(teamKey);
        initialEnemies.push({
          id: Math.random(),
          name: `Bot ${teamKey.charAt(0).toUpperCase()}${i + 1}`,
          team: teamKey,
          position: {
            x: spawnPos.x,
            y: 0,
            z: spawnPos.z
          },
          rotation: Math.random() * Math.PI * 2,
          health: 100,
          maxHealth: 100,
          level: 1,
          isDead: false,
          deathTime: 0,
          aiState: {
            targetX: 0,
            targetZ: 0,
            lastShot: 0,
            behavior: Math.random() > 0.5 ? 'aggressive' : 'defensive'
          }
        });
      }
    });
    setEnemies(initialEnemies);

    // Generate bushes for hiding
    const initialBushes = [];
    for (let i = 0; i < 15; i++) {
      initialBushes.push({
        id: Math.random(),
        position: {
          x: (Math.random() - 0.5) * 90,
          y: 0,
          z: (Math.random() - 0.5) * 90
        },
        radius: 2
      });
    }
    setBushes(initialBushes);

    // Generate trees for filler
    const initialTrees = [];
    for (let i = 0; i < 25; i++) {
      initialTrees.push({
        id: Math.random(),
        position: {
          x: (Math.random() - 0.5) * 95,
          y: 0,
          z: (Math.random() - 0.5) * 95
        },
        height: 3 + Math.random() * 2
      });
    }
    setTrees(initialTrees);
    
    // Handle window resize
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [gameState, selectedTeam]);
  
  // Keyboard and mouse controls
  useEffect(() => {
    const handleKeyDown = (e) => {
      keysPressed.current[e.key.toLowerCase()] = true;
      if (e.key === 'Escape' && gameState === 'playing') {
        setGameState('paused');
      }
      if (e.key.toLowerCase() === 'p' && gameState === 'playing') {
        setAdminConsole(prev => ({ ...prev, isOpen: !prev.isOpen }));
      }
    };

    const handleKeyUp = (e) => {
      keysPressed.current[e.key.toLowerCase()] = false;
    };

    const handleMouseMove = (e) => {
      // Store screen mouse position
      mousePosition.current.x = (e.clientX / window.innerWidth) * 2 - 1;
      mousePosition.current.y = -(e.clientY / window.innerHeight) * 2 + 1;

      // Calculate world position using raycaster
      if (cameraRef.current) {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(
          new THREE.Vector2(mousePosition.current.x, mousePosition.current.y),
          cameraRef.current
        );

        // Raycast to y=0 plane (ground)
        const planeY = 0;
        const distance = (planeY - cameraRef.current.position.y) / raycaster.ray.direction.y;
        const point = raycaster.ray.origin.clone().add(
          raycaster.ray.direction.clone().multiplyScalar(distance)
        );

        mousePosition.current.worldX = point.x;
        mousePosition.current.worldZ = point.z;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('mousemove', handleMouseMove);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, [gameState]);
  
  // Game loop
  useEffect(() => {
    if (gameState !== 'playing') return;
    
    let lastTime = performance.now();
    
    const gameLoop = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      
      // Player movement (decreased base dexterity)
      const moveSpeed = 10 * deltaTime;
      let newX = player.position.x;
      let newZ = player.position.z;

      if (keysPressed.current['w']) newZ -= moveSpeed;
      if (keysPressed.current['s']) newZ += moveSpeed;
      if (keysPressed.current['a']) newX -= moveSpeed;
      if (keysPressed.current['d']) newX += moveSpeed;

      // Bounds checking
      newX = Math.max(-48, Math.min(48, newX));
      newZ = Math.max(-48, Math.min(48, newZ));

      // Rotate player to face mouse cursor
      const dx = mousePosition.current.worldX - newX;
      const dz = mousePosition.current.worldZ - newZ;
      const newRotation = Math.atan2(dx, dz);

      // Update player position and rotation
      if (playerMeshRef.current && !player.isDead) {
        playerMeshRef.current.position.x = newX;
        playerMeshRef.current.position.z = newZ;
        playerMeshRef.current.rotation.y = newRotation;

        // Death animation
        if (player.health <= 0 && !player.isDead) {
          setPlayer(prev => ({ ...prev, isDead: true, deathTime: currentTime }));
        }

        if (player.isDead) {
          const deathProgress = (currentTime - player.deathTime) / 2000;
          playerMeshRef.current.rotation.x = deathProgress * Math.PI / 2;
          playerMeshRef.current.position.y = -deathProgress * 2;
        }
      }
      
      // Camera follow - locked to player center
      if (cameraRef.current) {
        cameraRef.current.position.x = newX;
        cameraRef.current.position.z = newZ + 15;
        cameraRef.current.lookAt(newX, 0, newZ);
      }
      
      // Shooting - now follows mouse direction
      const fireRateCooldown = 500 / player.upgrades.fireRate;
      if (keysPressed.current[' '] && currentTime - lastShotTime.current > fireRateCooldown && !player.isDead) {
        shootTowardsMouse(newX, newZ, mousePosition.current.worldX, mousePosition.current.worldZ);
        lastShotTime.current = currentTime;
      }

      // Send player updates to server (throttled to ~20 updates per second)
      if (multiplayerState.roomCode && currentTime - (lastUpdateTime.current || 0) > 50) {
        sendToServer({
          type: 'PLAYER_UPDATE',
          position: { x: newX, y: 0, z: newZ },
          rotation: newRotation,
          health: player.health,
          level: player.level,
          xp: player.xp,
          upgrades: player.upgrades
        });
        lastUpdateTime.current = currentTime;
      }

      // Apply health decay if admin mode not enabled
      if (!adminConsole.noHealthDecay && player.health > 0) {
        setPlayer(prev => ({
          ...prev,
          health: Math.max(0, prev.health - 0.5 * deltaTime)
        }));
      }
      
      // Update enemies (AI)
      setEnemies(prevEnemies => prevEnemies.map(enemy => {
        // Check if bot should respawn (after 10 seconds)
        if (enemy.isDead) {
          const timeSinceDeath = currentTime - enemy.deathTime;
          if (timeSinceDeath > 10000) { // 10 seconds
            // Respawn bot at team spawn area
            const spawnPos = getSpawnPosition(enemy.team);
            enemy.position.x = spawnPos.x;
            enemy.position.z = spawnPos.z;
            enemy.health = enemy.maxHealth;
            enemy.isDead = false;
            enemy.deathTime = 0;
          }
          return enemy; // Don't process AI for dead bots
        }

        const dx = player.position.x - enemy.position.x;
        const dz = player.position.z - enemy.position.z;
        const distToPlayer = Math.sqrt(dx * dx + dz * dz);

        // AI behavior - only attack players on different teams
        if (enemy.aiState.behavior === 'aggressive' && distToPlayer < 30 && enemy.team !== selectedTeam) {
          // Chase player
          const angle = Math.atan2(dz, dx);
          enemy.position.x += Math.cos(angle) * 8 * deltaTime;
          enemy.position.z += Math.sin(angle) * 8 * deltaTime;
          enemy.rotation = angle - Math.PI / 2;

          // Shoot at player
          if (currentTime - enemy.aiState.lastShot > 1000) {
            shootEnemy(enemy);
            enemy.aiState.lastShot = currentTime;
          }
        } else {
          // Random movement
          if (Math.random() < 0.02) {
            enemy.aiState.targetX = (Math.random() - 0.5) * 80;
            enemy.aiState.targetZ = (Math.random() - 0.5) * 80;
          }

          const tdx = enemy.aiState.targetX - enemy.position.x;
          const tdz = enemy.aiState.targetZ - enemy.position.z;
          const dist = Math.sqrt(tdx * tdx + tdz * tdz);

          if (dist > 2) {
            enemy.position.x += (tdx / dist) * 6 * deltaTime;
            enemy.position.z += (tdz / dist) * 6 * deltaTime;
            enemy.rotation = Math.atan2(tdz, tdx) - Math.PI / 2;
          }
        }

        // Bounds
        enemy.position.x = Math.max(-48, Math.min(48, enemy.position.x));
        enemy.position.z = Math.max(-48, Math.min(48, enemy.position.z));

        return enemy;
      }));
      
      // Update leaf piles (respawn logic)
      setRocks(prevRocks => prevRocks.map(rock => {
        if (rock.isDestroyed) {
          const timeSinceDestroyed = currentTime - rock.destroyedTime;
          if (timeSinceDestroyed > rock.respawnTime) {
            // Respawn leaf pile
            rock.isDestroyed = false;
            rock.destroyedTime = 0;
            rock.health = rock.maxHealth;
          }
        }
        return rock;
      }));

      // Update projectiles
      setProjectiles(prev => {
        return prev.map(proj => {
          proj.position.x += Math.cos(proj.direction) * proj.speed * deltaTime;
          proj.position.z += Math.sin(proj.direction) * proj.speed * deltaTime;
          proj.lifetime -= deltaTime;
          return proj;
        }).filter(proj => proj.lifetime > 0 &&
          Math.abs(proj.position.x) < 50 &&
          Math.abs(proj.position.z) < 50);
      });
      
      // Check collisions
      checkCollisions();
      
      // Update particles
      setParticles(prev => prev.map(p => ({
        ...p,
        lifetime: p.lifetime - deltaTime,
        position: {
          x: p.position.x + p.velocity.x * deltaTime,
          y: p.position.y + p.velocity.y * deltaTime,
          z: p.position.z + p.velocity.z * deltaTime
        }
      })).filter(p => p.lifetime > 0));
      
      setPlayer(prev => ({
        ...prev,
        position: { x: newX, y: 0, z: newZ },
        rotation: newRotation
      }));
      
      // Render scene
      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        rendererRef.current.render(sceneRef.current, cameraRef.current);
      }
      
      animationFrameId.current = requestAnimationFrame(gameLoop);
    };
    
    animationFrameId.current = requestAnimationFrame(gameLoop);
    
    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
    };
  }, [gameState, player, enemies, rocks, projectiles]);
  
  // Render rocks and enemies
  useEffect(() => {
    if (!sceneRef.current || gameState !== 'playing') return;
    
    // Clear old objects
    const objectsToRemove = [];
    sceneRef.current.children.forEach(child => {
      if (child.userData.isRock || child.userData.isEnemy || child.userData.isProjectile || child.userData.isParticle || child.userData.isMultiplayerPlayer || child.userData.isBush || child.userData.isTree) {
        objectsToRemove.push(child);
      }
    });
    objectsToRemove.forEach(obj => sceneRef.current.remove(obj));

    // Render leaf piles (only if not destroyed)
    rocks.forEach(rock => {
      if (rock.isDestroyed) return; // Don't render destroyed piles

      const size = rock.size === 'small' ? 1.5 : 2.2;
      const geometry = new THREE.SphereGeometry(size, 8, 6);
      geometry.scale(1, 0.4, 1); // Flatten to look like a pile
      const material = new THREE.MeshStandardMaterial({
        color: 0x8B4513, // Brown color for leaves
        roughness: 0.95,
        metalness: 0.0
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(rock.position.x, 0.3, rock.position.z);
      mesh.rotation.y = rock.rotation;
      mesh.castShadow = true;
      mesh.userData.isRock = true;
      mesh.userData.id = rock.id;
      sceneRef.current.add(mesh);
    });

    // Render bushes
    bushes.forEach(bush => {
      const geometry = new THREE.SphereGeometry(bush.radius, 8, 8);
      const material = new THREE.MeshStandardMaterial({
        color: 0x2d5016, // Dark green
        roughness: 0.9,
        metalness: 0.0
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(bush.position.x, bush.radius * 0.7, bush.position.z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.isBush = true;
      mesh.userData.id = bush.id;
      sceneRef.current.add(mesh);
    });

    // Render trees
    trees.forEach(tree => {
      const group = new THREE.Group();

      // Trunk
      const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, tree.height * 0.6, 8);
      const trunkMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a2511, // Brown trunk
        roughness: 0.9
      });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = tree.height * 0.3;
      trunk.castShadow = true;
      group.add(trunk);

      // Foliage
      const foliageGeometry = new THREE.ConeGeometry(1.2, tree.height * 0.7, 8);
      const foliageMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a4d0a, // Dark green foliage
        roughness: 0.8
      });
      const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
      foliage.position.y = tree.height * 0.8;
      foliage.castShadow = true;
      group.add(foliage);

      group.position.set(tree.position.x, 0, tree.position.z);
      group.userData.isTree = true;
      group.userData.id = tree.id;
      sceneRef.current.add(group);
    });
    
    // Render enemies as human characters (bigger size)
    enemies.forEach(enemy => {
      if (enemy.isDead) return; // Don't render dead bots

      const group = new THREE.Group();

      // Body - 1.5x bigger
      const bodyGeometry = new THREE.BoxGeometry(0.9, 1.5, 0.6);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: teams[enemy.team].color,
        roughness: 0.7
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.75;
      body.castShadow = true;
      group.add(body);

      // Head - 1.5x bigger
      const headGeometry = new THREE.SphereGeometry(0.45, 16, 16);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xffdbac,
        roughness: 0.8
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.95;
      head.castShadow = true;
      group.add(head);

      // Arms - 1.5x bigger
      const armGeometry = new THREE.BoxGeometry(0.3, 1.05, 0.3);
      const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
      leftArm.position.set(-0.75, 0.9, 0);
      leftArm.castShadow = true;
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
      rightArm.position.set(0.75, 0.9, 0);
      rightArm.castShadow = true;
      group.add(rightArm);

      // Legs - 1.5x bigger
      const legGeometry = new THREE.BoxGeometry(0.375, 1.05, 0.375);
      const legMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.8
      });

      const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.3, -0.525, 0);
      leftLeg.castShadow = true;
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.3, -0.525, 0);
      rightLeg.castShadow = true;
      group.add(rightLeg);

      group.position.set(enemy.position.x, 0, enemy.position.z);
      group.rotation.y = enemy.rotation;
      group.userData.isEnemy = true;
      group.userData.id = enemy.id;
      sceneRef.current.add(group);
    });

    // Render multiplayer players (bigger size)
    multiplayerState.players.forEach((otherPlayer, playerId) => {
      if (playerId === multiplayerState.playerId) return; // Don't render self

      const group = new THREE.Group();

      // Body - 1.5x bigger
      const bodyGeometry = new THREE.BoxGeometry(0.9, 1.5, 0.6);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: teams[otherPlayer.team]?.color || 0xffffff,
        roughness: 0.7,
        emissive: teams[otherPlayer.team]?.color || 0xffffff,
        emissiveIntensity: 0.2
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.75;
      body.castShadow = true;
      group.add(body);

      // Head - 1.5x bigger
      const headGeometry = new THREE.SphereGeometry(0.45, 16, 16);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xffdbac,
        roughness: 0.8
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.95;
      head.castShadow = true;
      group.add(head);

      // Arms - 1.5x bigger
      const armGeometry = new THREE.BoxGeometry(0.3, 1.05, 0.3);
      const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
      leftArm.position.set(-0.75, 0.9, 0);
      leftArm.castShadow = true;
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
      rightArm.position.set(0.75, 0.9, 0);
      rightArm.castShadow = true;
      group.add(rightArm);

      // Legs - 1.5x bigger
      const legGeometry = new THREE.BoxGeometry(0.375, 1.05, 0.375);
      const legMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.8
      });

      const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.3, -0.525, 0);
      leftLeg.castShadow = true;
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.3, -0.525, 0);
      rightLeg.castShadow = true;
      group.add(rightLeg);

      // Player name label (as sprite above head)
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;
      context.fillStyle = 'rgba(0, 0, 0, 0.7)';
      context.fillRect(0, 0, 256, 64);
      context.font = 'Bold 24px Arial';
      context.fillStyle = '#ffffff';
      context.textAlign = 'center';
      context.fillText(otherPlayer.name || 'Player', 128, 40);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.y = 3.5; // Higher position for bigger character
      sprite.scale.set(2, 0.5, 1);
      group.add(sprite);

      group.position.set(otherPlayer.position.x, 0, otherPlayer.position.z);
      group.rotation.y = otherPlayer.rotation;
      group.userData.isMultiplayerPlayer = true;
      group.userData.id = playerId;
      sceneRef.current.add(group);
    });
    
    // Render projectiles
    projectiles.forEach(proj => {
      const geometry = new THREE.SphereGeometry(0.3, 8, 8);
      const material = new THREE.MeshBasicMaterial({
        color: proj.color,
        emissive: proj.color,
        emissiveIntensity: 1
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(proj.position.x, 1, proj.position.z);
      mesh.userData.isProjectile = true;
      mesh.userData.id = proj.id;
      sceneRef.current.add(mesh);
    });
    
    // Render particles
    particles.forEach(particle => {
      const geometry = new THREE.SphereGeometry(0.2, 6, 6);
      const material = new THREE.MeshBasicMaterial({
        color: particle.color,
        transparent: true,
        opacity: particle.lifetime / particle.maxLifetime
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(particle.position.x, particle.position.y, particle.position.z);
      mesh.userData.isParticle = true;
      sceneRef.current.add(mesh);
    });
    
  }, [rocks, enemies, projectiles, particles, bushes, trees, gameState, multiplayerState]);
  
  const shootTowardsMouse = (x, z, mouseX, mouseZ) => {
    // Calculate direction from player to mouse
    const dx = mouseX - x;
    const dz = mouseZ - z;
    const baseDirection = Math.atan2(dz, dx);

    const directions = ['front', ...player.upgrades.extraCannons];
    const newProjectiles = [];

    directions.forEach(dir => {
      let angleOffset = 0;
      if (dir === 'side') {
        [-Math.PI / 2, Math.PI / 2].forEach(offset => {
          const proj = createProjectile(x, z, baseDirection + offset, true);
          newProjectiles.push(proj);
          // Send to server
          if (multiplayerState.roomCode) {
            sendToServer({
              type: 'PLAYER_SHOOT',
              position: { x, y: 1, z },
              direction: baseDirection + offset,
              projectileId: proj.id
            });
          }
        });
        return;
      }
      if (dir === 'back') angleOffset = Math.PI;
      if (dir === 'diagonal') {
        [-Math.PI / 4, Math.PI / 4, -3 * Math.PI / 4, 3 * Math.PI / 4].forEach(offset => {
          const proj = createProjectile(x, z, baseDirection + offset, true);
          newProjectiles.push(proj);
          // Send to server
          if (multiplayerState.roomCode) {
            sendToServer({
              type: 'PLAYER_SHOOT',
              position: { x, y: 1, z },
              direction: baseDirection + offset,
              projectileId: proj.id
            });
          }
        });
        return;
      }

      const proj = createProjectile(x, z, baseDirection + angleOffset, true);
      newProjectiles.push(proj);

      // Send to server
      if (multiplayerState.roomCode) {
        sendToServer({
          type: 'PLAYER_SHOOT',
          position: { x, y: 1, z },
          direction: baseDirection + angleOffset,
          projectileId: proj.id
        });
      }
    });

    setProjectiles(prev => [...prev, ...newProjectiles]);
  };

  const shoot = (x, z, rotation) => {
    const directions = ['front', ...player.upgrades.extraCannons];
    const newProjectiles = [];

    directions.forEach(dir => {
      let angleOffset = 0;
      if (dir === 'side') {
        [-Math.PI / 2, Math.PI / 2].forEach(offset => {
          newProjectiles.push(createProjectile(x, z, rotation + offset, true));
        });
        return;
      }
      if (dir === 'back') angleOffset = Math.PI;
      if (dir === 'diagonal') {
        [-Math.PI / 4, Math.PI / 4, -3 * Math.PI / 4, 3 * Math.PI / 4].forEach(offset => {
          newProjectiles.push(createProjectile(x, z, rotation + offset, true));
        });
        return;
      }

      newProjectiles.push(createProjectile(x, z, rotation + angleOffset, true));
    });

    setProjectiles(prev => [...prev, ...newProjectiles]);
  };
  
  const shootEnemy = (enemy) => {
    const proj = createProjectile(
      enemy.position.x,
      enemy.position.z,
      enemy.rotation + Math.PI / 2,
      false,
      enemy.team
    );
    setProjectiles(prev => [...prev, proj]);
  };

  const createProjectile = (x, z, direction, isPlayer, ownerTeam = null) => ({
    id: Math.random(),
    position: { x, y: 1, z },
    direction,
    speed: 40,
    lifetime: 3,
    damage: isPlayer ? player.upgrades.damage * 10 : 10,
    color: isPlayer ? teams[selectedTeam].color : teams[ownerTeam]?.color || 0xff0000,
    isPlayerProjectile: isPlayer,
    ownerTeam: isPlayer ? selectedTeam : ownerTeam
  });
  
  const checkCollisions = () => {
    const collisionData = {
      projectilesToRemove: new Set(),
      playerDamage: 0,
      xpGain: 0,
      particlesToCreate: [],
      rocksToUpdate: [],
      enemiesToUpdate: []
    };

    // Collect all collision data first
    projectiles.forEach(proj => {
      // Check leaf pile collisions
      rocks.forEach(rock => {
        if (rock.isDestroyed) return;

        const dx = proj.position.x - rock.position.x;
        const dz = proj.position.z - rock.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 2.5 && proj.isPlayerProjectile) {
          const newHealth = rock.health - proj.damage;
          collisionData.rocksToUpdate.push({
            id: rock.id,
            health: newHealth,
            isDestroyed: newHealth <= 0,
            destroyedTime: newHealth <= 0 ? currentTime : rock.destroyedTime
          });
          collisionData.particlesToCreate.push({ x: rock.position.x, z: rock.position.z, color: 0x8B4513 });
          collisionData.projectilesToRemove.add(proj.id);
          if (newHealth <= 0) {
            collisionData.xpGain += 20;
          }
        }
      });

      // Check enemy collisions
      if (proj.isPlayerProjectile || proj.ownerTeam) {
        enemies.forEach(enemy => {
          if (enemy.isDead) return;
          if (proj.ownerTeam === enemy.team) return; // Skip same team

          const dx = proj.position.x - enemy.position.x;
          const dz = proj.position.z - enemy.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);

          if (dist < 3) {
            const newHealth = enemy.health - proj.damage;
            collisionData.enemiesToUpdate.push({
              id: enemy.id,
              health: newHealth,
              isDead: newHealth <= 0,
              deathTime: newHealth <= 0 ? currentTime : enemy.deathTime
            });
            collisionData.particlesToCreate.push({ x: enemy.position.x, z: enemy.position.z, color: teams[enemy.team].color });
            collisionData.projectilesToRemove.add(proj.id);
            if (newHealth <= 0) {
              collisionData.xpGain += 50 * enemy.level;
            }
          }
        });
      }

      // Check player collision with projectiles from different teams
      if (proj.ownerTeam && proj.ownerTeam !== selectedTeam) {
        const dx = proj.position.x - player.position.x;
        const dz = proj.position.z - player.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 3) {
          collisionData.playerDamage += proj.damage;
          collisionData.particlesToCreate.push({ x: player.position.x, z: player.position.z, color: teams[selectedTeam].color });
          collisionData.projectilesToRemove.add(proj.id);
        }
      }
    });

    // Apply all state updates at once
    if (collisionData.projectilesToRemove.size > 0) {
      setProjectiles(prev => prev.filter(p => !collisionData.projectilesToRemove.has(p.id)));
    }

    if (collisionData.rocksToUpdate.length > 0) {
      setRocks(prev => prev.map(rock => {
        const update = collisionData.rocksToUpdate.find(u => u.id === rock.id);
        return update ? { ...rock, ...update } : rock;
      }));
    }

    if (collisionData.enemiesToUpdate.length > 0) {
      setEnemies(prev => prev.map(enemy => {
        const update = collisionData.enemiesToUpdate.find(u => u.id === enemy.id);
        return update ? { ...enemy, ...update } : enemy;
      }));
    }

    if (collisionData.playerDamage > 0) {
      setPlayer(prev => ({
        ...prev,
        health: Math.max(0, prev.health - collisionData.playerDamage)
      }));
    }

    if (collisionData.xpGain > 0) {
      gainXP(collisionData.xpGain);
    }

    collisionData.particlesToCreate.forEach(p => createParticles(p.x, p.z, p.color));
  };
  
  const createParticles = (x, z, color) => {
    const newParticles = [];
    for (let i = 0; i < 8; i++) {
      newParticles.push({
        position: { x, y: 1, z },
        velocity: {
          x: (Math.random() - 0.5) * 10,
          y: Math.random() * 5,
          z: (Math.random() - 0.5) * 10
        },
        color,
        lifetime: 0.5,
        maxLifetime: 0.5
      });
    }
    setParticles(prev => [...prev, ...newParticles]);
  };
  
  const gainXP = (amount) => {
    setPlayer(prev => {
      const newXP = prev.xp + amount;
      const requiredXP = getLevelRequirement(prev.level);

      if (newXP >= requiredXP) {
        // Level up! Show upgrade screen
        const allUpgrades = getAvailableUpgrades(prev.level + 1);
        if (allUpgrades.length > 0) {
          // Randomly select 3 upgrades (or all if less than 3)
          const shuffled = [...allUpgrades].sort(() => Math.random() - 0.5);
          const choices = shuffled.slice(0, Math.min(3, shuffled.length));
          setAvailableUpgradeChoices(choices);
          setShowUpgradeScreen(true);
        }

        return {
          ...prev,
          xp: newXP - requiredXP,
          level: prev.level + 1
        };
      }

      return { ...prev, xp: newXP };
    });
  };
  
  const applyUpgrade = (upgrade) => {
    setPlayer(prev => {
      const newUpgrades = { ...prev.upgrades };

      if (upgrade.type === 'damage') {
        newUpgrades.damage += 0.5;
      } else if (upgrade.type === 'fireRate') {
        newUpgrades.fireRate += 0.3;
      } else if (upgrade.type === 'extraCannons') {
        if (!newUpgrades.extraCannons.includes(upgrade.value)) {
          newUpgrades.extraCannons.push(upgrade.value);
        }
      } else if (upgrade.type === 'health') {
        setShowUpgradeScreen(false);
        setAvailableUpgradeChoices([]);
        return {
          ...prev,
          maxHealth: prev.maxHealth + 20,
          health: prev.health + 20,
          upgrades: newUpgrades
        };
      }

      setShowUpgradeScreen(false);
      setAvailableUpgradeChoices([]);
      return { ...prev, upgrades: newUpgrades };
    });
  };
  
  const startGame = () => {
    if (!playerName || !selectedTeam) return;
    setGameState('playing');
  };
  
  const respawn = () => {
    const spawnPos = getSpawnPosition(selectedTeam);
    setPlayer(prev => ({
      ...prev,
      position: { x: spawnPos.x, y: 0, z: spawnPos.z },
      health: prev.maxHealth,
      isDead: false,
      deathTime: 0,
      level: 1, // Reset level on death
      xp: 0,
      upgrades: {
        damage: 1,
        fireRate: 1,
        extraCannons: [],
        directions: ['front']
      }
    }));
  };

  // Admin console command processing
  const executeAdminCommand = (command) => {
    const parts = command.trim().toLowerCase().split(' ');
    const cmd = parts[0];

    switch (cmd) {
      case 'nohealthdecay':
      case 'godmode':
        setAdminConsole(prev => ({
          ...prev,
          noHealthDecay: !prev.noHealthDecay,
          command: ''
        }));
        console.log(`Health decay ${!adminConsole.noHealthDecay ? 'disabled' : 'enabled'}`);
        break;

      case 'levelup':
        const targetName = parts.slice(1).join(' ');
        if (!targetName) {
          // Level up the player
          setPlayer(prev => ({
            ...prev,
            level: prev.level + 1,
            xp: 0
          }));
          console.log('Player leveled up!');
        } else {
          // Level up specific enemy by name
          setEnemies(prev => prev.map(enemy => {
            if (enemy.name.toLowerCase() === targetName) {
              return { ...enemy, level: enemy.level + 1 };
            }
            return enemy;
          }));
          console.log(`Leveled up ${targetName}`);
        }
        setAdminConsole(prev => ({ ...prev, command: '' }));
        break;

      case 'addbot':
        const botTeam = parts[1] || Object.keys(teams)[Math.floor(Math.random() * Object.keys(teams).length)];
        const validTeam = teams[botTeam] ? botTeam : Object.keys(teams)[0];
        setEnemies(prev => [...prev, {
          id: Math.random(),
          name: `Bot ${Math.floor(Math.random() * 1000)}`,
          team: validTeam,
          position: {
            x: (Math.random() - 0.5) * 80,
            y: 0,
            z: (Math.random() - 0.5) * 80
          },
          rotation: Math.random() * Math.PI * 2,
          health: 100,
          maxHealth: 100,
          level: 1,
          aiState: {
            targetX: 0,
            targetZ: 0,
            lastShot: 0,
            behavior: Math.random() > 0.5 ? 'aggressive' : 'defensive'
          }
        }]);
        console.log(`Added bot on team ${validTeam}`);
        setAdminConsole(prev => ({ ...prev, command: '' }));
        break;

      case 'removebot':
        const botName = parts.slice(1).join(' ');
        if (botName) {
          setEnemies(prev => prev.filter(enemy =>
            enemy.name.toLowerCase() !== botName.toLowerCase()
          ));
          console.log(`Removed bot ${botName}`);
        } else {
          setEnemies(prev => prev.slice(0, -1));
          console.log('Removed last bot');
        }
        setAdminConsole(prev => ({ ...prev, command: '' }));
        break;

      case 'heal':
        setPlayer(prev => ({ ...prev, health: prev.maxHealth }));
        console.log('Player healed');
        setAdminConsole(prev => ({ ...prev, command: '' }));
        break;

      case 'clear':
        setAdminConsole(prev => ({ ...prev, command: '' }));
        break;

      case 'help':
        console.log('=== ADMIN COMMANDS ===');
        console.log('nohealthdecay / godmode - Toggle health decay');
        console.log('levelup [name] - Grant level up to player or bot');
        console.log('addbot [team] - Add a bot (red/blue/green)');
        console.log('removebot [name] - Remove bot by name or last bot');
        console.log('heal - Restore player health');
        console.log('clear - Clear command input');
        console.log('help - Show this help');
        setAdminConsole(prev => ({ ...prev, command: '' }));
        break;

      default:
        console.log(`Unknown command: ${cmd}. Type 'help' for commands.`);
        setAdminConsole(prev => ({ ...prev, command: '' }));
    }
  };
  
  useEffect(() => {
    if (player.health <= 0 && gameState === 'playing') {
      setTimeout(() => {
        respawn();
      }, 2000);
    }
  }, [player.health, gameState]);
  
  // Lobby Screen (Multiplayer Room Selection)
  if (gameState === 'lobby') {
    return (
      <div style={{
        width: '100vw',
        height: '100vh',
        background: 'linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #2a0a3e 100%)',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        fontFamily: '"Orbitron", sans-serif',
        color: '#fff',
        position: 'relative',
        overflow: 'hidden'
      }}>
        <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet" />

        <style>{`
          @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 0.8; }
          }
          @keyframes glow {
            0%, 100% { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff; }
            50% { text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff, 0 0 50px #00ffff; }
          }
        `}</style>

        <div style={{ textAlign: 'center', zIndex: 1 }}>
          <h1 style={{
            fontSize: '72px',
            fontWeight: 900,
            margin: '0 0 20px 0',
            animation: 'glow 2s ease-in-out infinite',
            letterSpacing: '8px',
            textTransform: 'uppercase'
          }}>
            NEXUS ARENA
          </h1>

          <p style={{
            fontSize: '20px',
            marginBottom: '50px',
            opacity: 0.8,
            letterSpacing: '4px'
          }}>
            MULTIPLAYER COMBAT PLATFORM
          </p>

          {/* Connection Status */}
          <div style={{
            marginBottom: '30px',
            padding: '10px 20px',
            background: multiplayerState.isConnected ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.2)',
            border: `2px solid ${multiplayerState.isConnected ? '#00ff00' : '#ff0000'}`,
            borderRadius: '10px',
            display: 'inline-block'
          }}>
            <div style={{ fontSize: '14px' }}>
              {multiplayerState.isConnected ? ' CONNECTED TO SERVER' : ' CONNECTING...'}
            </div>
          </div>

          {multiplayerState.error && (
            <div style={{
              marginBottom: '20px',
              padding: '15px',
              background: 'rgba(255, 0, 0, 0.2)',
              border: '2px solid #ff0000',
              borderRadius: '10px',
              color: '#ff0000'
            }}>
              {multiplayerState.error}
            </div>
          )}

          <div style={{
            background: 'rgba(0, 0, 0, 0.6)',
            padding: '40px',
            borderRadius: '20px',
            border: '2px solid rgba(0, 255, 255, 0.3)',
            backdropFilter: 'blur(10px)',
            maxWidth: '500px',
            boxShadow: '0 0 40px rgba(0, 255, 255, 0.2)'
          }}>
            <input
              type="text"
              value={playerName}
              onChange={(e) => setPlayerName(e.target.value)}
              placeholder="ENTER YOUR NAME"
              maxLength={15}
              style={{
                width: '100%',
                padding: '15px',
                fontSize: '18px',
                fontFamily: '"Orbitron", sans-serif',
                background: 'rgba(0, 0, 0, 0.5)',
                border: '2px solid rgba(0, 255, 255, 0.5)',
                borderRadius: '10px',
                color: '#00ffff',
                marginBottom: '30px',
                textAlign: 'center',
                textTransform: 'uppercase',
                letterSpacing: '2px',
                outline: 'none'
              }}
            />

            <div style={{ marginBottom: '30px' }}>
              <h3 style={{ fontSize: '20px', marginBottom: '15px', letterSpacing: '3px' }}>
                SELECT TEAM
              </h3>

              <div style={{ display: 'flex', gap: '10px', justifyContent: 'center', flexWrap: 'wrap' }}>
                {Object.entries(teams).map(([key, team]) => (
                  <button
                    key={key}
                    onClick={() => setSelectedTeam(key)}
                    style={{
                      padding: '15px 20px',
                      fontSize: '14px',
                      fontFamily: '"Orbitron", sans-serif',
                      fontWeight: 700,
                      background: selectedTeam === key
                        ? `linear-gradient(135deg, ${team.glowColor}, ${team.glowColor}88)`
                        : 'rgba(0, 0, 0, 0.5)',
                      border: `3px solid ${selectedTeam === key ? team.glowColor : 'rgba(255, 255, 255, 0.2)'}`,
                      borderRadius: '10px',
                      color: '#fff',
                      cursor: 'pointer',
                      transition: 'all 0.3s',
                      textTransform: 'uppercase',
                      letterSpacing: '1px',
                      boxShadow: selectedTeam === key ? `0 0 20px ${team.glowColor}` : 'none',
                      transform: selectedTeam === key ? 'scale(1.05)' : 'scale(1)'
                    }}
                  >
                    {team.name}
                  </button>
                ))}
              </div>
            </div>

            <div style={{ display: 'flex', gap: '15px', marginBottom: '20px' }}>
              <button
                onClick={createRoom}
                disabled={!playerName || !selectedTeam || !multiplayerState.isConnected}
                style={{
                  flex: 1,
                  padding: '20px',
                  fontSize: '18px',
                  fontFamily: '"Orbitron", sans-serif',
                  fontWeight: 900,
                  background: playerName && selectedTeam && multiplayerState.isConnected
                    ? 'linear-gradient(135deg, #00ff00, #00aa00)'
                    : 'rgba(100, 100, 100, 0.5)',
                  border: 'none',
                  borderRadius: '10px',
                  color: '#000',
                  cursor: playerName && selectedTeam && multiplayerState.isConnected ? 'pointer' : 'not-allowed',
                  textTransform: 'uppercase',
                  letterSpacing: '2px',
                  boxShadow: playerName && selectedTeam && multiplayerState.isConnected
                    ? '0 0 20px rgba(0, 255, 0, 0.5)'
                    : 'none'
                }}
              >
                CREATE ROOM
              </button>
            </div>

            <div style={{ fontSize: '16px', marginBottom: '15px', opacity: 0.8 }}>OR</div>

            <input
              type="text"
              value={multiplayerState.joinCode}
              onChange={(e) => setMultiplayerState(prev => ({ ...prev, joinCode: e.target.value.toUpperCase() }))}
              placeholder="ENTER ROOM CODE"
              maxLength={6}
              style={{
                width: '100%',
                padding: '15px',
                fontSize: '18px',
                fontFamily: '"Orbitron", sans-serif',
                background: 'rgba(0, 0, 0, 0.5)',
                border: '2px solid rgba(255, 255, 0, 0.5)',
                borderRadius: '10px',
                color: '#ffff00',
                marginBottom: '15px',
                textAlign: 'center',
                textTransform: 'uppercase',
                letterSpacing: '3px',
                outline: 'none'
              }}
            />

            <button
              onClick={() => joinRoom(multiplayerState.joinCode)}
              disabled={!playerName || !selectedTeam || !multiplayerState.joinCode || !multiplayerState.isConnected}
              style={{
                width: '100%',
                padding: '20px',
                fontSize: '18px',
                fontFamily: '"Orbitron", sans-serif',
                fontWeight: 900,
                background: playerName && selectedTeam && multiplayerState.joinCode && multiplayerState.isConnected
                  ? 'linear-gradient(135deg, #ffff00, #ffaa00)'
                  : 'rgba(100, 100, 100, 0.5)',
                border: 'none',
                borderRadius: '10px',
                color: '#000',
                cursor: playerName && selectedTeam && multiplayerState.joinCode && multiplayerState.isConnected ? 'pointer' : 'not-allowed',
                textTransform: 'uppercase',
                letterSpacing: '2px',
                boxShadow: playerName && selectedTeam && multiplayerState.joinCode && multiplayerState.isConnected
                  ? '0 0 20px rgba(255, 255, 0, 0.5)'
                  : 'none'
              }}
            >
              JOIN ROOM
            </button>
          </div>

          <div style={{ marginTop: '40px', opacity: 0.6, fontSize: '14px', letterSpacing: '2px' }}>
            <p>Create a room or join with a code to play with friends!</p>
          </div>
        </div>
      </div>
    );
  }

  // Menu Screen (Waiting Room)
  if (gameState === 'menu') {
    const playerCount = multiplayerState.players.size + 1; // +1 for self

    return (
      <div style={{
        width: '100vw',
        height: '100vh',
        background: 'linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #2a0a3e 100%)',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        fontFamily: '"Orbitron", sans-serif',
        color: '#fff',
        position: 'relative',
        overflow: 'hidden'
      }}>
        <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet" />
        
        {/* Animated background */}
        <div style={{
          position: 'absolute',
          width: '100%',
          height: '100%',
          background: 'radial-gradient(circle at 50% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%)',
          animation: 'pulse 4s ease-in-out infinite'
        }} />
        
        <style>{`
          @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 0.8; }
          }
          @keyframes glow {
            0%, 100% { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff; }
            50% { text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff, 0 0 50px #00ffff; }
          }
          @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
          }
        `}</style>
        
        <div style={{
          textAlign: 'center',
          zIndex: 1,
          animation: 'float 3s ease-in-out infinite'
        }}>
          <h1 style={{
            fontSize: '60px',
            fontWeight: 900,
            margin: '0 0 20px 0',
            animation: 'glow 2s ease-in-out infinite',
            letterSpacing: '8px',
            textTransform: 'uppercase'
          }}>
            WAITING ROOM
          </h1>

          {/* Room Code Display */}
          <div style={{
            fontSize: '32px',
            marginBottom: '30px',
            padding: '20px 40px',
            background: 'rgba(0, 255, 255, 0.2)',
            border: '3px solid #00ffff',
            borderRadius: '15px',
            display: 'inline-block',
            boxShadow: '0 0 30px rgba(0, 255, 255, 0.5)'
          }}>
            ROOM CODE: <span style={{ color: '#00ffff', fontWeight: 900, letterSpacing: '8px' }}>
              {multiplayerState.roomCode}
            </span>
          </div>

          <p style={{
            fontSize: '16px',
            marginBottom: '30px',
            opacity: 0.8,
            letterSpacing: '2px'
          }}>
            Share this code with your friends to join!
          </p>

          <div style={{
            background: 'rgba(0, 0, 0, 0.6)',
            padding: '30px',
            borderRadius: '20px',
            border: '2px solid rgba(0, 255, 255, 0.3)',
            backdropFilter: 'blur(10px)',
            maxWidth: '600px',
            boxShadow: '0 0 40px rgba(0, 255, 255, 0.2)',
            marginBottom: '30px'
          }}>
            <h3 style={{
              fontSize: '24px',
              marginBottom: '20px',
              letterSpacing: '3px',
              color: '#00ffff'
            }}>
              PLAYERS ({playerCount}/4)
            </h3>

            <div style={{ marginBottom: '20px' }}>
              {/* Your player */}
              <div style={{
                padding: '15px',
                marginBottom: '10px',
                background: `linear-gradient(135deg, ${teams[selectedTeam]?.glowColor || '#00ffff'}33, ${teams[selectedTeam]?.glowColor || '#00ffff'}11)`,
                border: `2px solid ${teams[selectedTeam]?.glowColor || '#00ffff'}`,
                borderRadius: '10px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
              }}>
                <div style={{ fontSize: '18px', fontWeight: 700 }}>
                  {playerName} <span style={{ fontSize: '12px', opacity: 0.7 }}>(YOU)</span>
                </div>
                <div style={{ fontSize: '14px', color: teams[selectedTeam]?.glowColor }}>
                  {teams[selectedTeam]?.name}
                </div>
              </div>

              {/* Other players */}
              {Array.from(multiplayerState.players.values()).map((p) => (
                <div key={p.id} style={{
                  padding: '15px',
                  marginBottom: '10px',
                  background: `linear-gradient(135deg, ${teams[p.team]?.glowColor || '#ffffff'}33, ${teams[p.team]?.glowColor || '#ffffff'}11)`,
                  border: `2px solid ${teams[p.team]?.glowColor || '#ffffff'}`,
                  borderRadius: '10px',
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center'
                }}>
                  <div style={{ fontSize: '18px', fontWeight: 700 }}>
                    {p.name}
                  </div>
                  <div style={{ fontSize: '14px', color: teams[p.team]?.glowColor }}>
                    {teams[p.team]?.name}
                  </div>
                </div>
              ))}
            </div>

            {/* Bot Configuration */}
            <div style={{
              marginBottom: '20px',
              padding: '20px',
              background: 'rgba(100, 100, 100, 0.2)',
              borderRadius: '10px',
              border: '1px solid rgba(255, 255, 255, 0.2)'
            }}>
              <h3 style={{ fontSize: '18px', marginBottom: '15px', color: '#ffff00' }}>
                BOT CONFIGURATION
              </h3>

              {Object.entries(teams).map(([teamKey, team]) => (
                <div key={teamKey} style={{
                  marginBottom: '15px',
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  padding: '10px',
                  background: `linear-gradient(135deg, ${team.glowColor}22, ${team.glowColor}11)`,
                  borderRadius: '8px',
                  border: `1px solid ${team.glowColor}`
                }}>
                  <div style={{ fontSize: '14px', fontWeight: 700, color: team.glowColor }}>
                    {team.name}
                  </div>

                  <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
                    <button
                      onClick={() => setBotConfig(prev => ({
                        ...prev,
                        [teamKey]: Math.max(0, (prev[teamKey] || 0) - 1)
                      }))}
                      style={{
                        padding: '5px 15px',
                        fontSize: '18px',
                        fontFamily: '"Orbitron", sans-serif',
                        fontWeight: 900,
                        background: 'rgba(255, 0, 0, 0.3)',
                        border: '2px solid #ff0044',
                        borderRadius: '5px',
                        color: '#fff',
                        cursor: 'pointer'
                      }}
                    >
                      -
                    </button>

                    <span style={{ fontSize: '18px', fontWeight: 700, minWidth: '30px', textAlign: 'center' }}>
                      {botConfig[teamKey] || 0}
                    </span>

                    <button
                      onClick={() => setBotConfig(prev => ({
                        ...prev,
                        [teamKey]: Math.min(2, (prev[teamKey] || 0) + 1)
                      }))}
                      style={{
                        padding: '5px 15px',
                        fontSize: '18px',
                        fontFamily: '"Orbitron", sans-serif',
                        fontWeight: 900,
                        background: 'rgba(0, 255, 0, 0.3)',
                        border: '2px solid #00ff00',
                        borderRadius: '5px',
                        color: '#fff',
                        cursor: 'pointer'
                      }}
                    >
                      +
                    </button>
                  </div>
                </div>
              ))}

              <div style={{ fontSize: '12px', opacity: 0.7, marginTop: '10px' }}>
                Configure 0-2 bots per team
              </div>
            </div>

            <button
              onClick={startGame}
              style={{
                width: '100%',
                padding: '20px',
                fontSize: '24px',
                fontFamily: '"Orbitron", sans-serif',
                fontWeight: 900,
                background: 'linear-gradient(135deg, #00ff00, #00aa00)',
                border: 'none',
                borderRadius: '10px',
                color: '#000',
                cursor: 'pointer',
                textTransform: 'uppercase',
                letterSpacing: '4px',
                boxShadow: '0 0 30px rgba(0, 255, 0, 0.5)',
                transition: 'all 0.3s',
                marginBottom: '10px'
              }}
            >
              START GAME
            </button>

            <button
              onClick={leaveRoom}
              style={{
                width: '100%',
                padding: '15px',
                fontSize: '16px',
                fontFamily: '"Orbitron", sans-serif',
                fontWeight: 700,
                background: 'rgba(255, 0, 0, 0.2)',
                border: '2px solid #ff0044',
                borderRadius: '10px',
                color: '#ff0044',
                cursor: 'pointer',
                textTransform: 'uppercase',
                letterSpacing: '2px',
                transition: 'all 0.3s'
              }}
            >
              LEAVE ROOM
            </button>
          </div>

          <div style={{
            marginTop: '20px',
            opacity: 0.6,
            fontSize: '14px',
            letterSpacing: '2px'
          }}>
            <p>CONTROLS: WASD - MOVE | MOUSE - AIM | SPACE - FIRE | P - ADMIN</p>
          </div>
        </div>
      </div>
    );
  }
  
  // Game Screen
  return (
    <div style={{ width: '100vw', height: '100vh', position: 'relative', overflow: 'hidden' }}>
      <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet" />
      
      <div ref={mountRef} style={{ width: '100%', height: '100%' }} />
      
      {/* HUD */}
      <div style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        pointerEvents: 'none',
        fontFamily: '"Orbitron", sans-serif',
        color: '#fff'
      }}>
        {/* Top HUD */}
        <div style={{
          position: 'absolute',
          top: '20px',
          left: '20px',
          right: '20px',
          display: 'flex',
          justifyContent: 'space-between',
          gap: '20px'
        }}>
          {/* Player Info */}
          <div style={{
            background: 'rgba(0, 0, 0, 0.8)',
            padding: '15px 25px',
            borderRadius: '10px',
            border: `2px solid ${teams[selectedTeam].glowColor}`,
            boxShadow: `0 0 20px ${teams[selectedTeam].glowColor}88`
          }}>
            <div style={{ fontSize: '20px', fontWeight: 700, marginBottom: '5px', color: teams[selectedTeam].glowColor }}>
              {playerName}
            </div>
            <div style={{ fontSize: '14px', opacity: 0.8 }}>
              {teams[selectedTeam].name}
            </div>
          </div>
          
          {/* Level and XP */}
          <div style={{
            background: 'rgba(0, 0, 0, 0.8)',
            padding: '15px 25px',
            borderRadius: '10px',
            border: '2px solid #00ffff',
            minWidth: '200px'
          }}>
            <div style={{ fontSize: '18px', fontWeight: 700, marginBottom: '8px' }}>
              LEVEL {player.level}
            </div>
            <div style={{
              background: 'rgba(0, 0, 0, 0.5)',
              height: '10px',
              borderRadius: '5px',
              overflow: 'hidden',
              border: '1px solid #00ffff'
            }}>
              <div style={{
                height: '100%',
                width: `${(player.xp / getLevelRequirement(player.level)) * 100}%`,
                background: 'linear-gradient(90deg, #00ffff, #00aaff)',
                boxShadow: '0 0 10px #00ffff',
                transition: 'width 0.3s'
              }} />
            </div>
            <div style={{ fontSize: '12px', marginTop: '5px', opacity: 0.7 }}>
              {player.xp} / {getLevelRequirement(player.level)} XP
            </div>
          </div>
          
          {/* Health */}
          <div style={{
            background: 'rgba(0, 0, 0, 0.8)',
            padding: '15px 25px',
            borderRadius: '10px',
            border: '2px solid #ff0044',
            minWidth: '200px'
          }}>
            <div style={{ fontSize: '18px', fontWeight: 700, marginBottom: '8px' }}>
              SHIELDS
            </div>
            <div style={{
              background: 'rgba(0, 0, 0, 0.5)',
              height: '10px',
              borderRadius: '5px',
              overflow: 'hidden',
              border: '1px solid #ff0044'
            }}>
              <div style={{
                height: '100%',
                width: `${(player.health / player.maxHealth) * 100}%`,
                background: player.health > 50
                  ? 'linear-gradient(90deg, #00ff00, #00aa00)'
                  : player.health > 25
                    ? 'linear-gradient(90deg, #ffaa00, #ff6600)'
                    : 'linear-gradient(90deg, #ff0044, #aa0022)',
                boxShadow: player.health > 50 ? '0 0 10px #00ff00' : '0 0 10px #ff0044',
                transition: 'width 0.3s, background 0.3s'
              }} />
            </div>
            <div style={{ fontSize: '12px', marginTop: '5px', opacity: 0.7 }}>
              {Math.floor(player.health)} / {player.maxHealth}
            </div>
          </div>
        </div>
        
        {/* Upgrades Display */}
        <div style={{
          position: 'absolute',
          top: '120px',
          right: '20px',
          background: 'rgba(0, 0, 0, 0.8)',
          padding: '15px',
          borderRadius: '10px',
          border: '2px solid #00ffff',
          maxWidth: '250px'
        }}>
          <div style={{ fontSize: '16px', fontWeight: 700, marginBottom: '10px' }}>
            LOADOUT
          </div>
          <div style={{ fontSize: '12px', opacity: 0.8 }}>
            <div>Damage: {player.upgrades.damage.toFixed(1)}x</div>
            <div>Fire Rate: {player.upgrades.fireRate.toFixed(1)}x</div>
            <div>Cannons: {['front', ...player.upgrades.extraCannons].join(', ')}</div>
          </div>
        </div>
        
        {/* Minimap */}
        <div style={{
          position: 'absolute',
          bottom: '20px',
          right: '20px',
          width: '200px',
          height: '200px',
          background: 'rgba(0, 0, 0, 0.9)',
          border: '2px solid #00ffff',
          borderRadius: '10px',
          boxShadow: '0 0 20px rgba(0, 255, 255, 0.3)'
        }}>
          <svg width="200" height="200" style={{ display: 'block' }}>
            {/* Grid */}
            <line x1="100" y1="0" x2="100" y2="200" stroke="#ffffff22" strokeWidth="1" />
            <line x1="0" y1="100" x2="200" y2="100" stroke="#ffffff22" strokeWidth="1" />
            
            {/* Player */}
            <circle
              cx={100 + (player.position.x / 50) * 100}
              cy={100 + (player.position.z / 50) * 100}
              r="5"
              fill={teams[selectedTeam].glowColor}
              stroke="#fff"
              strokeWidth="2"
            />
            
            {/* Enemies */}
            {enemies.map(enemy => (
              <circle
                key={enemy.id}
                cx={100 + (enemy.position.x / 50) * 100}
                cy={100 + (enemy.position.z / 50) * 100}
                r="3"
                fill={teams[enemy.team].glowColor}
                opacity="0.8"
              />
            ))}

            {/* Multiplayer Players */}
            {Array.from(multiplayerState.players.values()).map(otherPlayer => (
              <circle
                key={otherPlayer.id}
                cx={100 + (otherPlayer.position.x / 50) * 100}
                cy={100 + (otherPlayer.position.z / 50) * 100}
                r="4"
                fill={teams[otherPlayer.team]?.glowColor || '#ffffff'}
                stroke="#ffffff"
                strokeWidth="1"
                opacity="1"
              />
            ))}
            
            {/* Rocks */}
            {rocks.map(rock => (
              <rect
                key={rock.id}
                x={100 + (rock.position.x / 50) * 100 - 2}
                y={100 + (rock.position.z / 50) * 100 - 2}
                width="4"
                height="4"
                fill="#666"
                opacity="0.6"
              />
            ))}
          </svg>
        </div>
        
        {/* Enemy Count */}
        <div style={{
          position: 'absolute',
          bottom: '20px',
          left: '20px',
          background: 'rgba(0, 0, 0, 0.8)',
          padding: '15px 25px',
          borderRadius: '10px',
          border: '2px solid #ff0044',
          fontSize: '16px'
        }}>
          <div style={{ fontWeight: 700 }}>ENEMIES: {enemies.length}</div>
          <div style={{ fontSize: '14px', opacity: 0.7, marginTop: '5px' }}>
            ROCKS: {rocks.length}
          </div>
        </div>
        
        {/* Death Screen */}
        {player.health <= 0 && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'rgba(0, 0, 0, 0.95)',
            padding: '40px 60px',
            borderRadius: '20px',
            border: '3px solid #ff0044',
            textAlign: 'center',
            boxShadow: '0 0 40px rgba(255, 0, 68, 0.5)'
          }}>
            <div style={{ fontSize: '48px', fontWeight: 900, color: '#ff0044', marginBottom: '20px' }}>
              DESTROYED
            </div>
            <div style={{ fontSize: '20px', opacity: 0.8 }}>
              Respawning...
            </div>
          </div>
        )}
        
        {/* Level Up Notification */}
        {showUpgradeScreen && availableUpgradeChoices.length > 0 && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'rgba(0, 0, 0, 0.95)',
            padding: '40px',
            borderRadius: '20px',
            border: '3px solid #00ffff',
            pointerEvents: 'auto',
            boxShadow: '0 0 40px rgba(0, 255, 255, 0.5)',
            maxWidth: '800px'
          }}>
            <div style={{ fontSize: '36px', fontWeight: 900, marginBottom: '20px', color: '#00ffff' }}>
              LEVEL UP! - LEVEL {player.level}
            </div>

            <div style={{ marginBottom: '20px', fontSize: '18px', opacity: 0.8 }}>
              Select an upgrade:
            </div>

            <div style={{
              display: 'grid',
              gridTemplateColumns: availableUpgradeChoices.length === 1 ? '1fr' : 'repeat(auto-fit, minmax(200px, 1fr))',
              gap: '15px'
            }}>
              {availableUpgradeChoices.map((upgrade, i) => (
                <button
                  key={i}
                  onClick={() => applyUpgrade(upgrade)}
                  style={{
                    padding: '20px',
                    background: 'rgba(0, 255, 255, 0.1)',
                    border: '2px solid #00ffff',
                    borderRadius: '10px',
                    color: '#fff',
                    cursor: 'pointer',
                    transition: 'all 0.3s',
                    fontFamily: '"Orbitron", sans-serif'
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.background = 'rgba(0, 255, 255, 0.3)';
                    e.currentTarget.style.transform = 'scale(1.05)';
                    e.currentTarget.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.5)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.background = 'rgba(0, 255, 255, 0.1)';
                    e.currentTarget.style.transform = 'scale(1)';
                    e.currentTarget.style.boxShadow = 'none';
                  }}
                >
                  <div style={{ fontSize: '20px', fontWeight: 700, marginBottom: '10px' }}>
                    {upgrade.name}
                  </div>
                  <div style={{ fontSize: '14px', opacity: 0.8 }}>
                    {upgrade.description}
                  </div>
                </button>
              ))}
            </div>
          </div>
        )}
        
        {/* Admin Console */}
        {adminConsole.isOpen && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'rgba(0, 0, 0, 0.95)',
            padding: '30px',
            borderRadius: '15px',
            border: '3px solid #ff00ff',
            pointerEvents: 'auto',
            boxShadow: '0 0 40px rgba(255, 0, 255, 0.5)',
            minWidth: '500px',
            maxWidth: '600px'
          }}>
            <div style={{ fontSize: '28px', fontWeight: 900, marginBottom: '15px', color: '#ff00ff' }}>
              ADMIN CONSOLE
            </div>

            <div style={{ marginBottom: '15px', fontSize: '14px', opacity: 0.8 }}>
              <div style={{ marginBottom: '10px' }}>
                <strong>Available Commands:</strong>
              </div>
              <div style={{ fontFamily: 'monospace', fontSize: '12px', lineHeight: '1.6' }}>
                <div> <strong>nohealthdecay</strong> or <strong>godmode</strong> - Toggle health decay</div>
                <div> <strong>levelup [name]</strong> - Grant level up to player or bot</div>
                <div> <strong>addbot [team]</strong> - Add bot (red/blue/green)</div>
                <div> <strong>removebot [name]</strong> - Remove bot by name or last</div>
                <div> <strong>heal</strong> - Restore player health</div>
                <div> <strong>help</strong> - Show help in console</div>
              </div>
            </div>

            <div style={{ marginBottom: '15px', fontSize: '12px' }}>
              <div>Status: Health Decay <strong style={{ color: adminConsole.noHealthDecay ? '#00ff00' : '#ff0044' }}>
                {adminConsole.noHealthDecay ? 'DISABLED' : 'ENABLED'}
              </strong></div>
            </div>

            <input
              type="text"
              value={adminConsole.command}
              onChange={(e) => setAdminConsole(prev => ({ ...prev, command: e.target.value }))}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && adminConsole.command.trim()) {
                  executeAdminCommand(adminConsole.command);
                }
                if (e.key === 'Escape') {
                  setAdminConsole(prev => ({ ...prev, isOpen: false }));
                }
              }}
              placeholder="Enter command..."
              autoFocus
              style={{
                width: '100%',
                padding: '12px',
                fontSize: '14px',
                fontFamily: 'monospace',
                background: 'rgba(0, 0, 0, 0.7)',
                border: '2px solid #ff00ff',
                borderRadius: '8px',
                color: '#00ff00',
                outline: 'none'
              }}
            />

            <div style={{ marginTop: '10px', fontSize: '11px', opacity: 0.6 }}>
              Press ENTER to execute  ESC to close  P to toggle
            </div>
          </div>
        )}

        {/* Controls reminder */}
        <div style={{
          position: 'absolute',
          bottom: '240px',
          left: '20px',
          background: 'rgba(0, 0, 0, 0.7)',
          padding: '10px 15px',
          borderRadius: '8px',
          fontSize: '12px',
          opacity: 0.6,
          border: '1px solid rgba(255, 255, 255, 0.2)'
        }}>
          <div>WASD - Move</div>
          <div>MOUSE - Aim</div>
          <div>SPACE - Fire</div>
          <div>P - Admin Console</div>
          <div>ESC - Pause</div>
        </div>

        {/* Leave to Main Menu Button */}
        <div style={{
          position: 'absolute',
          top: '20px',
          right: '280px',
          pointerEvents: 'auto'
        }}>
          <button
            onClick={() => {
              if (window.confirm('Leave game and return to main menu?')) {
                leaveRoom();
              }
            }}
            style={{
              padding: '12px 20px',
              fontSize: '14px',
              fontFamily: '"Orbitron", sans-serif',
              fontWeight: 700,
              background: 'rgba(255, 0, 0, 0.3)',
              border: '2px solid #ff0044',
              borderRadius: '8px',
              color: '#ff0044',
              cursor: 'pointer',
              textTransform: 'uppercase',
              letterSpacing: '1px',
              transition: 'all 0.3s'
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.background = 'rgba(255, 0, 0, 0.5)';
              e.currentTarget.style.transform = 'scale(1.05)';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.background = 'rgba(255, 0, 0, 0.3)';
              e.currentTarget.style.transform = 'scale(1)';
            }}
          >
            Leave Game
          </button>
        </div>
      </div>
    </div>
  );
};


    // Render the app
    const { useState, useEffect, useRef, useCallback } = React;
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SpaceCombatGame />);
  </script>
</body>
</html>
